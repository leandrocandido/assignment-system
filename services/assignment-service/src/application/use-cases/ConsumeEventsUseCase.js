const Event = require('../../domain/entities/Event');
const Assignment = require('../../domain/entities/Assignment');
const logger = require('../../shared/utils/logger');

class ConsumeEventsUseCase {
  constructor(messageQueue, userRepository, eventRepository, assignmentRepository) {
    this.messageQueue = messageQueue;
    this.userRepository = userRepository;
    this.eventRepository = eventRepository;
    this.assignmentRepository = assignmentRepository;
    this.queueName = 'events.outbound';
  }

  async execute() {
    try {
      await this.messageQueue.consumeEvents(this.queueName, async (eventData) => {
        logger.info(`Processing event from queue: ${JSON.stringify(eventData)}`);
        
        const event = new Event(
          eventData.eventId,
          eventData.state,
          eventData.ruleType,
          eventData.region,
          eventData.location,
          eventData.severity,
          eventData.deviceId,
          eventData.cameraId,
          eventData.frameReference,
          eventData.createdAt
        );

        try {
          // Check if event is already processed
          if (await this.eventRepository.isDuplicate(event.eventId)) {
            logger.info(`Event ${event.id} is already processed, skipping`);
            return;
          }

          // Get active users
          const activeUsers = await this.userRepository.getActiveUsers();
          if (activeUsers.length === 0) {
            logger.info('No active users available for assignment');
            return;
          }

          

          // Get assignment counts for active users
          const userAssignmentCounts = await this.assignmentRepository.getUserAssignmentCounts();
          
          // Find user with minimum assignments
          const selectedUser = activeUsers.reduce((minUser, currentUser) => {
            const currentCount = userAssignmentCounts[currentUser.id] || 0;
            const minCount = userAssignmentCounts[minUser.id] || 0;
            return currentCount < minCount ? currentUser : minUser;
          }, activeUsers[0]);

          // Execute operations in a transaction
          await this.eventRepository.sequelize.transaction(async (t) => {
            // Create and save event if it doesn't exist
            if (!await this.eventRepository.eventExists(event.eventId)) {
              await this.eventRepository.saveEvent(event);
            }

            // Mark event as processed in dedup table
            await this.eventRepository.markEventAsProcessed(event.eventId);

            // Create assignment
            const assignment = new Assignment(
              null, // ID will be generated by the database
              event.eventId,
              selectedUser.id
            );
            await this.assignmentRepository.createAssignment(assignment);
          });

          // Update user's assignment count in Redis
          const newCount = (userAssignmentCounts[selectedUser.id] || 0) + 1;
          await this.userRepository.updateUserAssignmentCount(selectedUser.id, newCount);

          logger.info(`Event ${event.id} assigned to user ${selectedUser.id}`);
                
          
        } catch (error) {
          logger.error('Error processing event:', error);
          throw error;
        }
      });
    } catch (error) {
      logger.error('Error in consume events use case:', error);
      throw error;
    }
  }
}

module.exports = ConsumeEventsUseCase; 